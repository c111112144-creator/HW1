library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity tc is
    Port (
        rst       : in  STD_LOGIC;  -- 低有效 reset
        clk       : in  STD_LOGIC;
        count1_o  : out STD_LOGIC_VECTOR (7 downto 0); -- 0..9
        count2_o  : out STD_LOGIC_VECTOR (7 downto 0)  -- 253..79
    );
end tc;

architecture Behavioral of tc is
    type PSM_STATE is (s0, s1);
    signal state      : PSM_STATE := s0;

    signal count1_reg : unsigned(7 downto 0) := (others => '0');            -- 0..9
    signal count2_reg : unsigned(7 downto 0) := to_unsigned(253, 8);       -- 253..79

    -- next signals (combinational)
    signal next_state      : PSM_STATE;
    signal next_count1_reg : unsigned(7 downto 0);
    signal next_count2_reg : unsigned(7 downto 0);

    constant CNT1_MAX : unsigned(7 downto 0) := to_unsigned(9,8); -- 0..9
    constant CNT2_MIN : unsigned(7 downto 0) := to_unsigned(79,8); -- down to 79
    constant CNT2_INIT: unsigned(7 downto 0) := to_unsigned(253,8);
begin

    -- outputs
    count1_o <= std_logic_vector(count1_reg);
    count2_o <= std_logic_vector(count2_reg);

    -- combinational next-state / next-count logic
    comb_proc : process(state, count1_reg, count2_reg)
    begin
        -- defaults: keep values
        next_state      <= state;
        next_count1_reg <= count1_reg;
        next_count2_reg <= count2_reg;

        case state is
            when s0 =>
                -- 在 s0 時 count2 應為 253（保持）
                next_count2_reg <= CNT2_INIT;
                if count1_reg = CNT1_MAX then
                    -- 到達 9，下一個時鐘進入 s1，且把 count1 清 0（同時發生）
                    next_state      <= s1;
                    next_count1_reg <= to_unsigned(0,8);
                    -- 保持 count2 為 253(進入 s1 時起始為 253)
                    next_count2_reg <= CNT2_INIT;
                else
                    -- 繼續遞增 count1
                    next_count1_reg <= count1_reg + 1;
                end if;

            when s1 =>
                -- 在 s1 時 count1 應保持 0
                next_count1_reg <= to_unsigned(0,8);
                if count2_reg = CNT2_MIN then
                    -- 到達 79，下一個時鐘進入 s0，且把 count2 回到 253（同時發生）
                    next_state      <= s0;
                    next_count2_reg <= CNT2_INIT;
                    -- count1 在 s0 會從 0 開始（已由 next_count1_reg = 0 保證）
                else
                    -- 繼續遞減 count2
                    next_count2_reg <= count2_reg - 1;
                end if;

            when others =>
                next_state <= s0;
        end case;
    end process comb_proc;

    -- clocked registers
    seq_proc: process(clk, rst)
    begin
        if rst = '0' then
            state      <= s0;
            count1_reg <= (others => '0');
            count2_reg <= CNT2_INIT;
        elsif rising_edge(clk) then
            state      <= next_state;
            count1_reg <= next_count1_reg;
            count2_reg <= next_count2_reg;
        end if;
    end process seq_proc;

end Behavioral;
